#! /usr/bin/ruby

### TODO
#
# $ checksums { update | verify } [--verbose] [--key <signing key>] <directory>...
#
# * --exclude <filename pattern>
# * checksum for directories
#   use hash for dir/.checksums? -- requires post-order traversal
#   -> trigger update of parent directory
#

require 'digest/md5'
require 'gpgme'


module Directories
  class << self

    def each_bottom_up(*dirs, &block) # :yield: path
      each_dir(dirs, &block)
    end

    private
    
    def each_dir(dirs, &block)
      dirs.each do |dir|
        begin
          children = []
          Dir.open(dir) do |d|
            d.each do |it|
              next if it == '.' || it == '..'
              p = File.join(dir, it)
              next unless File.exist?(p) && File.lstat(p).directory?
              children << p
            end
          end
          each_dir(children, &block)
          block[dir]
        rescue Errno::ENOENT, Errno::EACCES
          ### really?
        end
      end
    end
  end
end


module Checksums
  VERSION = '0.1'
  CHECKSUM_FILENAME = '.checksums'

  CALLBACKS = [
    [ :valid_signature, 3 ],
    [ :invalid_signature, 3 ],
    [ :directory_unchanged, 1 ],
    [ :directory_changed, 1 ],
    [ :item_unchanged, 3 ],
    [ :item_changed, 4 ],
    [ :item_added, 2 ],
    [ :item_removed, 2 ]
  ].freeze

  class Checksums
    attr_reader :directory, :checksums
    
    def self.for_files(dir, paths)
      self.new(dir, checksums_from_paths(paths))
    end
    
    def self.from_formatted_checksums(dir, data)
      self.new(dir, parse_formatted_checksums(data))
    end

    def self.for_unchecked_directory(dir)
      self.new(dir, [])
    end
    
    def formatted
      checksums.map { |path, hash|
        "#{hash}  #{path}"
      }.join("\n") + "\n"
    end
    
    def ==(other)
      checksums == other.checksums
    end
    
    def report_changes(other, callbacks)
      compare_items = catch(:skip_item_comparison) do
        if @checksums == other.checksums
          callbacks.notify_directory_unchanged(directory)
          false
        else
          callbacks.notify_directory_changed(directory)
          true
        end
      end

      if compare_items
        expecteds = @checksums.dup
        actuals   = other.checksums.dup
        
        e_file, e_hash = expecteds.shift
        a_file, a_hash = actuals.shift
        
        until e_file.nil? && a_file.nil? do
          case 
          when e_file == a_file
            if e_hash == a_hash
              callbacks.notify_item_unchanged(directory, e_file, e_hash)
            else
              callbacks.notify_item_changed(directory, e_file, e_hash, a_hash)
            end
            e_file, e_hash = expecteds.shift
            a_file, a_hash = actuals.shift
          when a_file.nil? || e_file && (e_file < a_file)
            callbacks.notify_item_removed(directory, e_file)
            e_file, e_hash = expecteds.shift
          when e_file.nil? || a_file && (a_file < e_file)
            callbacks.notify_item_added(directory, a_file)
            a_file, a_hash = actuals.shift
          else
            raise 'There is a fault in the comparison algorithm.'
          end
        end
      end
    end
    
    def inspect
      checksums.inspect
    end
    
    private
    
    def initialize(dir, checksums)
      @directory, @checksums = dir, checksums
    end
    
    def self.checksums_from_paths(paths)
      paths.inject([]) do |sums, path|
        stat = File.lstat(path)
        hash = nil
        case
        when stat.symlink?
          hash = Digest::MD5.hexdigest(File.readlink(path))
        when stat.directory?
          hash = Digest::MD5.file(File.join(path, CHECKSUM_FILENAME)).hexdigest rescue ''
        when stat.file?
          hash = Digest::MD5.file(path).hexdigest
        end
        sums << [ File.basename(path), hash ]
        sums
      end.sort
    end

    def self.parse_formatted_checksums(data)
      data.lines.map { |l|
        hash, file = l.chomp.split('  ', 2)
        [ file, hash ]
      }
    end
  end


  class CheckedRootDirs
    include Enumerable
    
    def initialize(roots, signer)
      @roots = roots.map { |root| File.expand_path(root) }
      @signer = signer
    end
    
    def each
      Directories.each_bottom_up(*@roots) do |entity|
        yield CheckedDir.new(entity, @signer)
      end
    end
  end


  class CheckedDir
    def initialize(dir, signer = nil)
      @dir            = dir
      @stat           = File.lstat(dir)
      @signer         = signer || Signer.new
      @checksum_file  = File.join(@dir, CHECKSUM_FILENAME)
    end
    
    def ignored?
      empty? && !File.file?(File.join(@dir, CHECKSUM_FILENAME))
    end
    
    def needs_update?
      !File.exist?(@checksum_file) || (File.mtime(@checksum_file) < @stat.mtime)
    end
    
    def write_checksum_file
      sums = signed_checksums
      File.open(@checksum_file, "w") do |f|
        f.chown(nil, Process.egid) # override possible SGID on directory
        f.chmod(0644) # rw-r--r--
        f.write(sums)
      end
    end
    
    def verify_checksums(&block)
      callbacks = VerificationCallbacks.new(&block)
      catch(:skip_checksum_comparison) do
        expected = read_checksums(callbacks)
        expected.report_changes(checksums, callbacks)
      end
    end
    
    def delete_checksum_file
      File.delete(@checksum_file) if File.exist?(@checksum_file)
    end
    
    def to_s
      @dir
    end

    private

    def empty?
      entries.empty?
    end
    
    def entries
      @entries ||=
        Dir.entries(@dir).reject { |f| f == '.' || f == '..' || f == CHECKSUM_FILENAME }.map { |f|
          File.join(@dir, f)
        }
    end

    def checksums
      Checksums.for_files(@dir, entries)
    end
    
    def signed_checksums
      GPGME::clearsign(checksums.formatted, :signers => @signer.signers)
    end
    
    def read_checksums(callbacks = VerificationCallbacks.new)
      return Checksums.for_unchecked_directory(@dir) unless File.file?(@checksum_file)
      
      signed_sums = File.read(@checksum_file)
      verified_checksums = verify_signature(signed_sums)
      
      if verified_checksums[:valid]
        callbacks.notify_valid_signature(@dir, @signer, verified_checksums[:message])
      else
        callbacks.notify_invalid_signature(@dir, @signer, verified_checksums[:message])
      end
      
      Checksums.from_formatted_checksums(@dir, verified_checksums[:checksums])
    end

    def verify_signature(sums)
      {}.tap do |result|
        result[:checksums]  = GPGME::verify(sums) do |signature|
          result[:valid]    = @signer.valid_signature?(signature)
          result[:message]  = signature.to_s
        end
      end
    end
  end


  class Signer
    def initialize(signer = nil)
      @signer = signer
    end
    
    def signers
      @signer ? [signer_key] : nil
    end
    
    def valid_signature?(signature)
      (GPGME::gpgme_err_code(signature.status) == GPGME::GPG_ERR_NO_ERROR) &&
          acceptable_signature?(signature)
    end
    
    def acceptable_signature?(signature)
      acceptable_keyids.include?(signature.fingerprint[-16..-1])
    end
    
    def to_s
      keys = acceptable_keys.map { |key|
        "#{key.subkeys[0].keyid} #{key.uids[0].uid}"
      }
      (keys.length > 1 ? 'any of ' : '') + keys.join(', ')
    end
    
    def self.null_object
      @null_object ||= NullSigner.new
    end
    
    private
    
    class NullSigner
      def signers; nil; end
      def valid_signature?(s); true; end
      def acceptable_signature?(s); true; end
      def to_s; "Null Signer"; end
    end
    
    def signer_key
      @signer_key ||= resolve_key(@signer)
    end
    
    def resolve_key(key_or_name)
      GPGME::check_version({}) # required to ensure GPGME is initialized properly
      GPGME::resolve_keys(key_or_name, true, [:sign]).first
    end
    
    def acceptable_keys
      @acceptable_keys ||= begin
        GPGME::check_version({}) # required to ensure GPGME is initialized properly
        GPGME::list_keys(@signer || '', true, [:sign])
      end
    end

    def acceptable_keyids
      @acceptable_keyids ||= acceptable_keys.map { |k| k.subkeys[0].keyid }
    end
  end

  private
    
  class VerificationCallbacks
    def initialize
      yield self if block_given?
    end

    CALLBACKS.each do |(name, arg_count)|
      args = (1..arg_count).map { |i| "arg#{i}" }.join(', ')
      class_eval <<-END
        def #{name}(&block)
          @_#{name}_handler = block
        end
        def notify_#{name}(#{args})
          @_#{name}_handler && @_#{name}_handler.call(#{args})
        end
      END
    end
    
  end
end


if $0 == __FILE__

require 'optparse'

$verbose = false
$check_signatures_only = false
$check_dirs_only = false
$signer = nil
$force_update = false

def dirs(root_dirs)
  Checksums::CheckedRootDirs.new(root_dirs, $signer).reject(&:ignored?)
end

def update_checksums(root_dirs)
  puts "Updating checksums..." if $verbose
  dirs(root_dirs).select { |d| $force_update || d.needs_update? }.each do |checked_dir|
    puts checked_dir if $verbose
    checked_dir.write_checksum_file
  end
end

def verify_checksums(root_dirs)
  puts "Verifying checksums..." if $verbose
  dirs(root_dirs).each do |checked_dir|

    checked_dir.verify_checksums do |on|
      on.valid_signature do |dir, signer, message|
        if $check_signatures_only
          puts "Valid signature on #{dir}" if $verbose
          throw :skip_checksum_comparison
        end
      end
      
      on.invalid_signature do |dir, signer, message|
        puts "Invalid signature on #{dir}."
        puts "Expected signature from #{signer}"
        puts "Got: #{message}"
        puts
        throw :skip_checksum_comparison if $check_signatures_only
      end
      
      on.directory_unchanged do |dir|
        puts "unchanged #{dir}" if $verbose
      end
      
      on.directory_changed do |dir|
        if $check_dirs_only
          puts "DIRECTORY CHANGED #{dir}"
          throw :skip_item_comparison
        end
      end
      
      on.item_changed do |dir, file, expected_hash, actual_hash|
        puts "ITEM CHANGED #{File.join(dir, file)}"
      end
      
      on.item_added do |dir, file|
        puts "ITEM ADDED #{File.join(dir, file)}"
      end

      on.item_removed do |dir, file|
        puts "ITEM REMOVED #{File.join(dir, file)}"
      end
    end
  end
end


def main(args)
  command = nil
  
  loop do
    case args.first
    when 'update'
      command = :update
      args.shift
    when 'verify'
      command = :verify
      args.shift
    else
      break
    end
  end

  opts = OptionParser.new
  opts.banner = "Usage: #{opts.program_name} { update | verify } [options] directory..."
  opts.on('-s KEY', '--signer KEY', String, "Key used for signing and verifying signatures.") { |val|
    $signer = Checksums::Signer.new(val)
  }
  opts.on('-g', '--signatures-only', "Only verify signatures.") {
    $check_signatures_only = true
  }
  opts.on('-d', '--dirs-only', "Only check whether directories are unchanged") {
    $check_dirs_only = true
  }
  opts.on('-f', '--force-rebuild', "Rebuild all checksums.") {
    $force_update = true
  }
  opts.on('-v', '--verbose', "Display extra information.") {
    $verbose = true
  }
  opts.on_tail('--version', "Show version.") {
    puts Checksums::VERSION
    exit
  }
  root_dirs = opts.parse(args)
  
  $signer ||= Checksums::Signer.new
  
  case command
  when :update
    update_checksums root_dirs
  when :verify
    verify_checksums root_dirs
  else
    $stderr.puts 'Please specify a command, one of `update` and `verify`.'
  end
end


main(ARGV)

end
